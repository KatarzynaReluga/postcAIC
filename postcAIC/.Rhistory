1
list_constraints
scale_mvrnorm
p = p_full
starting_points = matrix(0, nrow = p,
ncol = n_starting_points)
for (l in 1:p) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, l] = temp_initial
}
n_models_to_compare = nrow(modelset_matrix) -
1
for (l in 1:p) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, l] = temp_initial
}
temp_initial
dim(starting_points)
starting_points[, l]
l
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, l] = temp_initial
starting_points[, l]
l
for (l in 1:p) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, l] = temp_initial
}
l
l in 1:p
p
for (l in 1:p) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, l] = temp_initial
}
temp_initial
starting_points[, l]
l
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
temp_initial
l
for (k in 1:p) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
}
k
k=1
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
for (k in 1:p) {
temp_initial = NULL
#loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
}
k
index_for_loop = 1:p
index_for_loop
for (k in index_for_loop) {
temp_initial = NULL
#loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
#       loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
}
k
temp_initial
check_sum0
check_negative_elements
temp_initial
check_sum0
list_constraints_k
temp
check_negative_elements
check_sum0
starting_points
for (k in index_for_loop) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
}
for (k in index_for_loop) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
}
sum(check_negative_elements < 0)
check_negative_elements
loop
index_for_loop = 1:p
for (k in index_for_loop) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
}
index_for_loop
starting_points
for (k in 1:n_starting_points) {
temp_initial = NULL
loop = 1
check_sum0 = n_models_to_compare
check_negative_elements = numeric(n_models_to_compare)
while (check_sum0 != 0) {
temp_initial = rmvn(1, mu = rep(0, p), V = scale_mvrnorm * diag(p))
for (i in 1:n_models_to_compare)      {
list_constraints_k = list_constraints[[i]]
temp = temp_initial %*% list_constraints_k[[1]] %*% temp_initial +
list_constraints_k[[2]] %*% temp_initial + list_constraints_k[[3]]
check_negative_elements[i] = temp
}
check_sum0 = sum(check_negative_elements < 0)
loop=loop+1
#        print(loop)
}
starting_points[, k] = temp_initial
}
starting_points
devtools::load_all()
# Post-cAIC CI for mixed and fixed parameters -------------------------------------
#a = Sys.time()
postcAIC_CI_results = postcAIC_CI(cAIC_min, degcAIC_models,
Z, X_full, X_cluster_full,
G_full, R_full, V_full,
beta_sel, mu_sel,
modelset  = "part_subset",
common = c(1:2),
modelset_matrix, x_beta_lin_com,
n_starting_points = 5,
scale_mvrnorm = 10)
postcAIC_CI_results$beta_PoSI_CI_up
postcAIC_CI_results$beta_PoSI_CI_do
beta_sel
sig_u_sel = cAIC_model_set$sig_u_sel
sig_e_sel = cAIC_model_set$sig_e_sel
indices_sel = cAIC_model_set$indices_sel
X_cluster_sel = cAIC_model_set$X_cluster_full[, indices_sel]
C_cluster_sel = cbind(as.matrix(X_cluster_sel), diag(n))
R_sel = cAIC_model_set$R_sel
V_sel = cAIC_model_set$V_sel
G_sel = cAIC_model_set$G_sel
naive_CI_results = naive_CI(beta_sel, mu_sel,
G_sel, R_sel, V_full,
sig_u_sel, sig_e_sel,
X_full, Z, C_cluster_sel = C_cluster_sel,
clusterID, indices_sel = indices_sel,
type_MSE_mixed = "corrected",
x_beta_lin_com)
# Post-OBSP CI for mixed parameters -------------------------------------
sig_u_full = cAIC_model_set$sig_u_full
sig_e_full = cAIC_model_set$sig_e_full
postOBSP_CI_results = postOBSP_CI(X_full, y, clusterID, Z, X_cluster_full,
G_full, V_full, R_full,
sig_u_full, sig_e_full,
modelset_matrix,
boot = 1000)
postOBSP_CI_results
a=Sys.time()
postOBSP_CI_results = postOBSP_CI(X_full, y, clusterID, Z, X_cluster_full,
G_full, V_full, R_full,
sig_u_full, sig_e_full,
modelset_matrix,
boot = 10)
b=Sys.time()
b-a
p_full = ncol(X_full)
m_total = nrow(Z)
n = nrow(G_full)
m_i = as.data.frame(table(clusterID))$Freq
t_Z = t(Z)
invV_full = solve(V_full)
Ga = as.matrix(diag(m_total) - Z%*%G_full%*%t_Z%*%invV_full)
Ga_sq = crossprod(Ga)
gamma_full = sig_u_full/(sig_u_full+sig_e_full/m_i)
g1_full = (1 - gamma_full) * sig_u_full
y_cluster_mean = aggregate(y ~ clusterID, FUN = "mean")[,-1]
beta_model_matrix = matrix(0, nrow = nrow(modelset_matrix),
ncol = p_full)
OBSP_models = numeric(nrow(modelset_matrix))
# Compute OBSP for the set of models ---------------------------------------------------------------------
#X_list = list()
mu_hat_model = list()
#Ga = diag(m_total)-Z%*%G_m5%*%t.Z%*%solV_m5
for (k in 1 : nrow(modelset_matrix)) {
covariates = modelset_matrix[k, ]
indices0 <- (1:ncol(X_full)) * covariates
indices = indices0[indices0!=0]
X = format_data_matrix(as.matrix(X_full[, indices]))
#  X_list[[k]] <- X
t_X = t(X)
X_cluster <- format_data_matrix(as.matrix(X_cluster_full[, indices]))
temp = as.matrix(solve(crossprod(X, crossprod(Ga_sq, X))))
beta_model = temp%*%t_X%*%Ga_sq%*%y
#y_Xbeta_dif = y - X%*%beta_temp
y_Xbeta_dif = y - crossprod(t_X, beta_model)
P_model = Ga%*%X%*%temp%*%t_X%*%Ga
penalty = sum(diag(P_model%*%Ga%*%as.matrix(R_full)))
OBSP_models[k] = t(y_Xbeta_dif)%*%Ga_sq%*%(y_Xbeta_dif) +
2 * penalty
u_model = gamma_full*(y_cluster_mean - X_cluster%*%beta_model)
mu_hat_model[[k]] = X_cluster%*%beta_model + u_model
beta_model_matrix[k, indices] <- beta_model
}
k
covariates = modelset_matrix[k, ]
indices0 <- (1:ncol(X_full)) * covariates
indices = indices0[indices0!=0]
X = format_data_matrix(as.matrix(X_full[, indices]))
#  X_list[[k]] <- X
t_X = t(X)
X_cluster <- format_data_matrix(as.matrix(X_cluster_full[, indices]))
temp = as.matrix(solve(crossprod(X, crossprod(Ga_sq, X))))
beta_model = temp%*%t_X%*%Ga_sq%*%y
#y_Xbeta_dif = y - X%*%beta_temp
y_Xbeta_dif = y - crossprod(t_X, beta_model)
P_model = Ga%*%X%*%temp%*%t_X%*%Ga
penalty = sum(diag(P_model%*%Ga%*%as.matrix(R_full)))
OBSP_models[k] = t(y_Xbeta_dif)%*%Ga_sq%*%(y_Xbeta_dif) +
2 * penalty
u_model = gamma_full*(y_cluster_mean - X_cluster%*%beta_model)
mu_hat_model[[k]] = X_cluster%*%beta_model + u_model
beta_model_matrix[k, indices] <- beta_model
OBSP_min = which.min(OBSP_models)
covariates_sel = modelset_matrix[OBSP_min, ]
indices0_sel <- (1:ncol(X_full)) * covariates_sel
indices_sel = indices0_sel[indices0_sel != 0]
u_boot_true = matrix(0, nrow = boot, ncol = n)
mu_boot_true = matrix(0, nrow = boot, ncol = n)
boot = 10
u_boot_true = matrix(0, nrow = boot, ncol = n)
mu_boot_true = matrix(0, nrow = boot, ncol = n)
gamma_full_boot = matrix(0, nrow = boot, ncol = n)
u_boot_hat = matrix(0, nrow = boot, ncol = n)
mu_boot_hat = matrix(0, nrow = boot, ncol = n)
sig_u_full_boot = numeric(boot)
sig_e_full_boot = numeric(boot)
a = Sys.time()
for (b in 1:boot)  {
e_boot = rnorm(m_total, 0, sqrt(sig_e_full))
u_boot = rnorm(n, 0, sqrt(sig_u_full))
beta_select = beta_model_matrix[OBSP_min,]
y_boot = X_full %*% beta_select + rep(u_boot, m_i) + e_boot
y_cluster_mean_boot = aggregate(y_boot ~ clusterID, FUN = "mean")[, -1]
# Boot true mu  ------------------------------------------------------------------------------
u_boot_true[b, ] = gamma_full * (y_cluster_mean_boot - as.matrix(X_cluster_full) %*%
beta_select)
mu_boot_true[b, ] = as.matrix(X_cluster_full) %*% beta_select + u_boot_true[b, ]
# Estimate boostrap data ----------------------------------------------------------------------------------
params = estimate_NERM(
X = X_full[, indices_sel],
y = y_boot,
clusterID = clusterID,
X_cluster = X_cluster_full[, indices_sel]
)
sig_u_full_boot[b] = params$sig_u
sig_e_full_boot[b] = params$sig_e
R_boot = params$R
G_boot = params$G
V_boot = params$V
invV_boot = params$invV
invR_boot = params$invR
#################
Ga_boot = as.matrix(diag(m_total) - Z %*% G_boot %*% t_Z %*% invV_boot)
Ga_sq_boot = crossprod(Ga_boot)
temp_boot = as.matrix(solve(crossprod(
X_full[, indices],
crossprod(Ga_sq_boot, X_full[, indices])
)))
beta_model_temp = temp_boot %*% t(X_full[, indices]) %*% Ga_sq_boot %*%
y_boot
gamma_full_boot[b, ] = sig_u_full_boot[b] / (sig_u_full_boot[b] + sig_e_full_boot[b] /
m_i)
u_boot_hat[b, ] = gamma_full_boot[b,] * (y_cluster_mean_boot - as.matrix(X_cluster_full) %*%
beta_select)
mu_boot_hat[b,] = as.matrix(X_cluster_full) %*% beta_select + u_boot_hat[b, ]
}
b = Sys.time()
b-a
g1_boot = (1 - gamma_full_boot) * sig_u_full_boot
mse_b = 2 * g1_full - mean(g1_boot) + colMeans((mu_boot_hat - mu_boot_true) ^ 2)
rmse_b = sqrt(mse_b)
# Construct interval ---------------------------------------------------------------------------------
mu_hat_sel = mu_hat_model[[OBSP_min]]
postOBSP_up = mu_hat_sel + 1.96 * rmse_b
OBSP_min
# Construct interval ---------------------------------------------------------------------------------
mu_hat_sel = mu_hat_model[[OBSP_min]]
mu_hat_model
a = Sys.time()
for (k in 1 : nrow(modelset_matrix)) {
covariates = modelset_matrix[k, ]
indices0 <- (1:ncol(X_full)) * covariates
indices = indices0[indices0!=0]
X = format_data_matrix(as.matrix(X_full[, indices]))
#  X_list[[k]] <- X
t_X = t(X)
X_cluster <- format_data_matrix(as.matrix(X_cluster_full[, indices]))
temp = as.matrix(solve(crossprod(X, crossprod(Ga_sq, X))))
beta_model = temp%*%t_X%*%Ga_sq%*%y
#y_Xbeta_dif = y - X%*%beta_temp
y_Xbeta_dif = y - crossprod(t_X, beta_model)
P_model = Ga%*%X%*%temp%*%t_X%*%Ga
penalty = sum(diag(P_model%*%Ga%*%as.matrix(R_full)))
OBSP_models[k] = t(y_Xbeta_dif)%*%Ga_sq%*%(y_Xbeta_dif) +
2 * penalty
u_model = gamma_full*(y_cluster_mean - X_cluster%*%beta_model)
mu_hat_model[[k]] = X_cluster%*%beta_model + u_model
beta_model_matrix[k, indices] <- beta_model
}
b = Sys.time()
OBSP_min = which.min(OBSP_models)
covariates_sel = modelset_matrix[OBSP_min, ]
indices0_sel <- (1:ncol(X_full)) * covariates_sel
indices_sel = indices0_sel[indices0_sel != 0]
k
b-a
getwd()
devtools::check()
install.packages("dplyr")
install.packages("ks")
install.packages("tmg")
devtools::check()
install.packages("C:/Users/katar/Downloads/tmg_0.3.tar.gz", repos = NULL, type = "source")
devtools::check()
require(devtools)
install_version("tmg", version = "0.3", repos = "http://cran.r-project.org")
library(postcAIC)
devtools::load_all()
librar(postcAIC)
library(postcAIC)
